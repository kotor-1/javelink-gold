"""""" import cv2 import numpy as np from typing import Tuple, List import logging from app.models.schemas import ViewType, ScaleMethod from app.services.detectors import PoseDetector from app.config import DEFAULT_PERSON_HEIGHT, AUTO_SCALE_COEFFICIENT, MARKER_SIZE_M logger = logging.getLogger(__name__) def calculate_scale( frames: np.ndarray, keypoints: np.ndarray, method: ScaleMethod, view: ViewType ) -> Tuple[float, List[str]]: """ /px Returns: m_per_px: / notes: """ notes = [] if method == ScaleMethod.MARKER: # m_per_px = detect_markers(frames[0], view) if m_per_px is None: # uto notes.append("Marker not detected, falling back to auto scale") method = ScaleMethod.AUTO if method == ScaleMethod.AUTO or m_per_px is None: # m_per_px = estimate_from_person(keypoints) notes.append("Using auto scale from person height estimation") # px = 0.1mm0cm if m_per_px < 0.0001 or m_per_px > 0.1: logger.warning(f"Unusual scale detected: {m_per_px} m/px") m_per_px = 0.002 # px = 2mm notes.append("Scale value out of range, using default") return m_per_px, notes def detect_markers(frame: np.ndarray, view: ViewType) -> Optional[float]: """ Returns: m_per_px: one: """ # TODO: # 1. / # 2. ArUco # 3. QR # hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV) # lower_red = np.array([0, 120, 70]) upper_red = np.array([10, 255, 255]) mask1 = cv2.inRange(hsv, lower_red, upper_red) lower_red = np.array([170, 120, 70]) upper_red = np.array([180, 255, 255]) mask2 = cv2.inRange(hsv, lower_red, upper_red) mask = mask1 | mask2 # contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) # if len(contours) >= 2: # contours = sorted(contours, key=cv2.contourArea, reverse=True) # centers = [] for cnt in contours[:2]: M = cv2.moments(cnt) if M["m00"] != 0: cx = int(M["m10"] / M["m00"]) cy = int(M["m01"] / M["m00"]) centers.append((cx, cy)) if len(centers) == 2: # 2 dist_px = np.linalg.norm(np.array(centers[0]) - np.array(centers[1])) if dist_px > 50: # # 1m m_per_px = MARKER_SIZE_M / dist_px logger.info(f"Marker detected: {dist_px:.1f}px = {MARKER_SIZE_M}m") return m_per_px return None def estimate_from_person(keypoints: np.ndarray) -> float: """ Returns: m_per_px: """ # mean_keypoints = np.mean(keypoints, axis=0) # shoulder_y = (mean_keypoints[PoseDetector.LEFT_SHOULDER, 1] + mean_keypoints[PoseDetector.RIGHT_SHOULDER, 1]) / 2 # ankle_y = (mean_keypoints[PoseDetector.LEFT_ANKLE, 1] + mean_keypoints[PoseDetector.RIGHT_ANKLE, 1]) / 2 # height_px = abs(ankle_y - shoulder_y) if height_px > 0: # -5% estimated_height = DEFAULT_PERSON_HEIGHT * 0.85 m_per_px = estimated_height / height_px logger.info(f"Auto scale: {height_px:.1f}px = {estimated_height:.2f}m (estimated)") return m_per_px # return 0.002 # 1px = 2mm 