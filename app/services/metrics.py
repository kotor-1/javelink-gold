""""" import numpy as np from scipy.signal import savgol_filter from typing import Optional import logging from app.models.schemas import Metrics, Handedness from app.services.events import Events from app.services.detectors import PoseDetector from app.config import SAVGOL_WINDOW, SAVGOL_POLY logger = logging.getLogger(__name__) def calculate_side_metrics( keypoints: np.ndarray, events: Events, fps: float, m_per_px: float, object_positions: Optional[np.ndarray] = None ) -> Metrics: """ Returns: Metrics: """ metrics = Metrics() if events.release_frame is None: logger.warning("Release frame not detected") return metrics # k = 5 # start = max(0, events.release_frame - k) end = min(len(keypoints), events.release_frame + k) # right_wrist = keypoints[start:end, PoseDetector.RIGHT_WRIST, :] left_wrist = keypoints[start:end, PoseDetector.LEFT_WRIST, :] # right_speed = np.linalg.norm(np.gradient(right_wrist, axis=0), axis=1).mean() left_speed = np.linalg.norm(np.gradient(left_wrist, axis=0), axis=1).mean() if right_speed > left_speed: trajectory = right_wrist else: trajectory = left_wrist # trajectory_smooth = savgol_filter(trajectory, min(len(trajectory), 5), 2, axis=0) # t = np.arange(len(trajectory_smooth)) / fps # if len(t) >= 3: # x px = np.polyfit(t, trajectory_smooth[:, 0], 1) vx = px[0] # pixel/sec # y 2 py = np.polyfit(t, trajectory_smooth[:, 1], 2) vy = py[1] # pixel/sec at t=0 # y theta_rad = np.arctan2(-vy, vx) metrics.release_angle_deg = np.degrees(theta_rad) # v_pix_per_sec = np.sqrt(vx**2 + vy**2) metrics.release_speed_mps = v_pix_per_sec * m_per_px # release_y = keypoints[events.release_frame, PoseDetector.RIGHT_WRIST, 1] ground_y = keypoints[:, PoseDetector.RIGHT_ANKLE, 1].max() # height_pix = ground_y - release_y # metrics.release_height_m = height_pix * m_per_px # shoulder_y = (keypoints[events.release_frame, PoseDetector.LEFT_SHOULDER, 1] + keypoints[events.release_frame, PoseDetector.RIGHT_SHOULDER, 1]) / 2 height_estimate = (ground_y - shoulder_y) * m_per_px * 1.15 # if height_estimate > 0: metrics.release_height_ratio = metrics.release_height_m / height_estimate # if events.plant_frame is not None: delta_frames = events.release_frame - events.plant_frame metrics.plant_to_release_ms = (delta_frames / fps) * 1000 return metrics def calculate_rear_metrics( keypoints: np.ndarray, events: Events, fps: float, m_per_px: float, handedness: Handedness ) -> Metrics: """ Returns: Metrics: """ metrics = Metrics() if events.plant_frame is None: logger.warning("Plant frame not detected") return metrics plant_idx = events.plant_frame # # - left_knee = keypoints[plant_idx, PoseDetector.LEFT_KNEE, :] left_ankle = keypoints[plant_idx, PoseDetector.LEFT_ANKLE, :] right_knee = keypoints[plant_idx, PoseDetector.RIGHT_KNEE, :] right_ankle = keypoints[plant_idx, PoseDetector.RIGHT_ANKLE, :] # if left_ankle[1] > right_ankle[1]: # y = foot_vec = left_ankle - left_knee else: foot_vec = right_ankle - right_knee # progress_vec = np.array([1, 0]) # cos_angle = np.dot(foot_vec, progress_vec) / (np.linalg.norm(foot_vec) * np.linalg.norm(progress_vec)) metrics.plant_foot_progression_deg = np.degrees(np.arccos(np.clip(cos_angle, -1, 1))) # - left_shoulder = keypoints[plant_idx, PoseDetector.LEFT_SHOULDER, :] right_shoulder = keypoints[plant_idx, PoseDetector.RIGHT_SHOULDER, :] left_hip = keypoints[plant_idx, PoseDetector.LEFT_HIP, :] right_hip = keypoints[plant_idx, PoseDetector.RIGHT_HIP, :] shoulder_vec = right_shoulder - left_shoulder hip_vec = right_hip - left_hip # if handedness == Handedness.LEFT: shoulder_vec = -shoulder_vec hip_vec = -hip_vec # cos_angle = np.dot(shoulder_vec, hip_vec) / (np.linalg.norm(shoulder_vec) * np.linalg.norm(hip_vec)) metrics.shoulder_hip_separation_deg = np.degrees(np.arccos(np.clip(cos_angle, -1, 1))) # if events.penultimate_frame is not None and events.release_frame is not None: # hip_center = (keypoints[:, PoseDetector.LEFT_HIP, :] + keypoints[:, PoseDetector.RIGHT_HIP, :]) / 2 # 3 start = events.penultimate_frame end = events.release_frame # x x_trajectory = hip_center[start:end, 0] # if len(x_trajectory) > 1: std_x = np.std(x_trajectory) metrics.lane_alignment_error_cm = std_x * 2 * m_per_px * 100 # cm return metrics 